Gfx is a package that provides a common abstraction above os dependent drawing/compute APIs like OpenGL, Metal and DirectX.
It provides DirectX11 level of control.

## Basic Concepts
### Specification
Gfx is divided in 2 parts: the frontend and the backend. The former provides a common API that is valid for every drawing API and is referred as Specification in the docs.
The frontend also does some basic debug checking.

### Implementations
The second part of the gfx package is referred as implementation. Its scope is to interpret the commands from the frontend and convert them to the appropriate API.

Those are the planned backends:
- First class support/effort
	- OpenGL 4 (easiest to implement)
	- Metal (MacOS support)
	- DirectX 11
- Second class support/effort
	- OpenGL 3 + OpenCL 1.2 (MacOS temporary + older devices, can be dropped since Metal and DirectX 11 are supported on every single reasonable device, aka 2012 and newer)
	- Vulkan (far future, not really necessary since gfx provides DirectX 11 level of control)
	- DirectX 12 (see Vulkan)
- Academic masturbation
	- Software renderer (requires shader emulation)

In order for the backend to communicate with the frontend, a table of virtual functions is used. The backend will override the table once it is initialized. The table is located under the variable name `CONTEXT_INSTANCE.procs`.
Other than those procs there are 4 ulterior callback that the backend must implement:
- `init`: used to initialize the backend and the virtual function table
- `deinit`: used to deinitialize the backend
- `pre_window_init`: called before `init`, and before the window is created
- `post_frame`: called after every frame
Those callbacks are provided using the `Backend_Initializer` struct.

### Handles
Handles are abstract types that represent a Gfx object. Internally they are stored as a pointer that the implementation can interpret.
Since they are pointers they can be shared, moved and modified by multiple instances of the code. A copy of an handle is always a reference, except when using the appropriate functions.
```go
// texture is an handle.
texture := gfx.texture_new(Texture_Descriptor {
	type = .Texture_2D,
}, [2]uint{ 100, 100 })

// Copy by reference.
texture2 := texture

// Also texture1 has been affected.
gfx.texture_resize(texture2, [2]uint { 50, 50 })
```

### Threading
The entire API is thread safe. The backend is responsible to synchronize itself if the graphics API is not thread safe (like OpenGL).
The specification indicates what functions should be async, but the implementation may ignore it if it is not feasible for the graphics API used (like in OpenGL). Function that are not defined to be async by the implementation must be automatically synchronized by the implementation.
All the functions that are async are indicated in this document by the pseudo-attribute `@(async)` and take a pointer to a `Sync` object. If the pointer is `nil`, then the function will wait as it was synchronous. The `sync` object can be waited by the user using `sync_await`.

## Common API Specification
### Gfx_Descriptor
This struct is used by the user to provide common information usefull for the frontend initialization.
```go
Gfx_Descriptor :: struct {
	allocator: mem.Allocator,
	loggel: log.Logger,
	debug: bool,
}
```

### Backend_User_Initialization_Data
This is a common struct that contains the user's common information for initializing a backend.
```go
Backend_User_Initialization_Data :: struct {
	allocator: mem.Allocator,
	logger: log.Logger,
	debug: bool,
	extra_data: rawptr,
}
```

### Backend_Initializer
This is a structure generated by the backend and it's used to initialize the frontend in conjunction with `Gfx_Descriptor` and `Backend_User_Initialization_Data`.
```go
Backend_Initializer :: struct {
	// returns false if the initialization has failed.
	init_proc: proc(user_init_data: Backend_User_Initialization_Data, 
		init_data: Backend_Initialization_Data) -> bool,
	deinit_proc: proc(),
	pre_window_init_proc: proc() -> bool,
	post_frame_proc: proc(handle: glfw.WindowHandle),
}
```

### Gfx
This is not a real type, but is an abstract type that represents the package as a whole.
`init` must be called after `pre_window_init` and `post_frame` must be called after every frame. The suggested option is to use the `platform` module to automate this process.
```go
pre_window_init :: proc(desciptor: Gfx_Descriptor, initializer: Backend_Initializer)
	-> bool {}
init :: proc(window_handle: glfw.WindowHandle, 
	user_init_data: Backend_User_Initialization_Data) -> bool {}
deinit :: proc() {}
post_frame :: proc(handle: glfw.WindowHandle) {}
```

### Backend_Info
This struct contains common information about the backend currently used. It is generated by `backend_get_info` and must be freed by the user.
```go
Backend_Info :: struct {
	name: string,
	version: Version,
}

backendinfo_free :: proc(info: Backend_Info) {}
```

### Backend
This type does not actually exists. It is a singleton and represents the current implementation used.
```go
backend_get_info :: proc() -> Backend_Info {}
```

### Device_Info
This struct contains common information of the currently utilized device. It is generated by `device_get_info` and must be freed by the user.
```go
Device_Info :: struct {
	device_name: string,
	driver_info: string,
	api_info: string,

	device_type: Device_Type,

	// limits to be added in the future
}

deviceinfo_free :: proc(info: Device_Info) {}
```

### Device_Info_List
An array that contains the `Device_Info` of every device present in the system. It is generated by `get_deviceinfolist` and must be freed by the user using `deviceinfolist_free` (which will free also all the `Device_Info`s int the list).
```go
Device_Info_List :: []Device_Info

deviceinfolist_free :: proc(list: Device_Info_List) {}
```

### Device
This type does not actually exist. It is a singleton and represent the physical and logical device.
It must be set from the `Device_Requirements`.
```go
get_deviceinfolist :: proc() -> Device_Info_List {}

// The index references the Device_Info_List returned by `get_deviceinfolist`.
device_set :: proc(index: uint) -> bool {}

// Return the device info. Return nil if the device has not been chosen yet.
device_get_info :: proc() -> Maybe(Device_Info) {}

// Tries and creates a swapchain using the provided descriptor. 
device_try_set_swapchain :: proc(descriptor: Swapchain_Descriptor) ->
	Swapchain_Set_Error {}

// Creates a best-effort swapchain trying to keep its properties as close as the
// ones provided by the descriptor. It is necessary to use for the implementations 
// that return `.Unavaliable_Functionality` from `device_try_set_swapchain`.
device_set_swapchain :: proc(descriptor: Swapchain_Descriptor) -> 
	Swapchain_Set_Error {}
```

### Swapchain_Descriptor
```go
Swapchain_Descriptor :: struct {
	present_mode: Present_Mode,
	size: [2]uint,
	refresh_rate: uint, // in Hz
	format: Image_Format,
}
```

### Swapchain_Info
```go
Swapchain_Info :: struct {
	present_mode: Present_Mode,
	size: [2]uint,
	refresh_rate: uint,
	format: Image_Format,
}
```

### Swapchain
This type does not actually exist. It is a singleton and represents a swapchain. It is set by `device_set_swapchain` and `device_try_set_swapchain`.
```go
// Returns nil if the swapchain has not been already created or if the backend cannot
// provide the necessary information.
swapchain_get_info :: proc() -> Maybe(Swapchain_Info) {}

// Returns false if the resize was not successfull.
swapchain_resize :: proc(size: [2]uint) -> bool {}

// Returns nil if the swapchain has not been initialized.
swapchain_get_rendertarget :: proc() -> Render_Target {}
```

### Buffer_Descriptor
Describes what properties a buffer should have.
```go
Buffer_Descriptor :: struct {
	type: Buffer_Type,
    usage: Buffer_Usage,
    index_type: Index_Type,
}
```

### Buffer
This handle represents a vertex buffer, index buffer or uniform buffer. It is a dynamic buffer by default. The memory management is provided by the implementation.
```go
Buffer :: distinct rawptr
```

## Common Types
### Device_Type
An enum that specifies the classification of a certain physical device.
```go
Device_Type :: enum {
	Software,         // Software rasterizer, MS WARP
	Power_Efficient,  // Integrated graphics card
	Performance,      // Dedicated graphics card
	Unknown,          // The backend cannot determine the type of device or the user
					  // does not require any
}
```

### Swapchain_Set_Error
```go
Swapchain_Set_Error :: enum {
	Ok,
	Unavaliable_Functionality, // The implementation cannot select the device as it is
	                           // missing this functionality (OpenGL), so the
	                           // implementation is no able to define whatever or not
	                           // the requirements are achieved. It is not an error.
	Impossible_Functionality,  // The requirements are not possible to be achieved by
							   // by the current implementation (Headless rendering on
							   // OpenGL).
	Illegal_Size,
	Illegal_Format,
	Illegal_Refresh_Rate,
	// ... To add regarding limits
}
```

### Version
```go
Version :: struct {
	major: uint,
	minor: uint,
	revision: uint,
}
```

### Buffer_Type
```go
Buffer_Type :: enum {
    Vertex_Buffer,
    Index_Buffer,
    Uniform_Buffer,
}
```

### Buffer_Usage
```go
Buffer_Usage :: enum {
    Static_Draw,
    Dynamic_Draw,
}
```

### Index_Type
```go
Index_Type :: enum {
    U8,
    U16,
    U32,
}
```

### Present_Mode
```go
Present_Mode :: enum {
	Immediate, // Frames submitted are sent to the gpu without waiting. Has tearing.
	Fifo,      // Waits for vsync.
	Mailbox,   // Similar to immediate, but has not tearing.
}
```

### Backend_Initialization_Data
```go
Backend_Initialization_Data :: struct {
	window_handle: glfw.WindowHandle,
}
```

## Backend API Specification
```go
backend_get_info :: proc() -> Backend_Info {}
backendinfo_free :: proc(info: Backend_Info) {}

deviceinfo_free :: proc(info: Device_Info) {}

deviceinfolist_free :: proc(list: Backend_List_Info) {}

get_deviceinfolist :: proc() -> Device_Info_List {}
device_set :: proc(index: uint) -> bool {}
device_check_swapchain_descriptor :: proc(descriptor: Swapchain_Descriptor)
	-> Swapchain_Set_Error {}
// Provides a best-effort set.
device_set_swapchain :: proc(descriptor: Swapchain_Descriptor) {}

device_get_info :: proc() -> Maybe(Device_Info) {}

swapchain_get_info :: proc() -> Maybe(Swapchain_Info) {}
swapchain_resize :: proc(size: [2]uint) -> bool {}
swapchain_get_rendertarget :: proc() -> Render_Target {}
```

## Todos
- Define behaviour in case that a device is re-set after it has already been used.